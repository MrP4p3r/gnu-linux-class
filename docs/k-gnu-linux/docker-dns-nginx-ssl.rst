.. _docker-dns-nginx-ssl:

===============
Курсовая работа
===============

Цели и задачи
=============

Целью работы является разработка легковесного контейнера, предоставляющего
доступ к контейнеризированных приложениям и автоматизирующего процесс
получения бесплатного SSL сертификата.

В работе рассмотрены:

    1. Настройка VDS сервера в качестве хост системы для службы Docker.
    2. Раработка легковесного контейнера автоматизирующего процесс получения SSL
       сертификата, дополнительно выполняющего роль DNS.
    3. Запуск контейнеризированных сервисов с использованием разработки.

Используемые технологии
=======================

В наличии имеется VDS сервер, работающий на базе KVM виртуализации.
На сервере установлена 64-разрядная версия дистрибутива
GNU/Linux CentOS 7.3. Сервер был арендован на хостинге https://myvps.ru.

Предлагается запускать контейнеризированные приложения на этом сервере,
а доступ к ним предоставлять через контейнеризированный Nginx
в роли обратного прокси (англ. reverse proxy). Доступ к приложениям
будет осуществляться через доменные имена. Поэтому контейнер должен
дополнительно содержать легковесный DNS сервер и средство для
редактирования доменной зоны. Также предполагается автоматизировать
процесс получения бесплатного SSL сертификата внутри контейнера.

В качестве DNS сервера был выбран PowerDNS.  // TODO

В качестве средства для получения сертификатов был выбран Acme.sh.  // TODO

Для того, чтобы держать все сервисы включенными: PowerDNS, Nginx, службу cron для
автоматического продления сертификатов через acme.sh, можно использовать supervisor.
Однако будучи написанным на python, supervisor требует наличие интерпретатора
python в контейнере. Это заметно увеличит размер контейнера,
поэтому были рассмотрены альтернативы.

Реализаций альтернатив supervisor довольно много. Автором работы
были рассмотрены некоторые из них:

    * `Supervisord (имплементация на GO) https://github.com/ochinchina/supervisord`_
    * `Immortal <https://github.com/immortal/immortal>`_
    * `Gosuv <https://github.com/codeskyblue/gosuv>`_

Supervisord имеет некоторые тонкие недостатки, связанные с конфигурацией
для предоставления доступа к управлению запущенным демоном. Gosuv немного
сыроват. И помимо этого не совсем подходит для использования внутри
контейнера. Однако он предоставляет, веб-интерфейс для мониторинга процессов.
Впрочем, для запуска трех процессов (Nginx, PowerDNS и crond) это
немного избыточно.

Самым удобным вариантом по установке, конфигурации и управлению оказался
Immortal. На каждый процесс, за которым будет следить Immortal необходимо
описать отдельный файл. Конфигурации каждой "службы" должны лежать в одной
директории. В процессе работы Immortal следит за изменениями в конфигурациях
и автоматически перезапускает службу при изменении параметров в конфигурационном
файле службы.

Концепция
=========

Потенциального пользователя контейнера не хочется заставлять изучать все
нюасны, касающиеся работы с выбранными средствами, поэтому набор команд для
пользователя необходимо свести к минимуму. В первую очередь, это сам процесс
получения сертификата и добавления виртуального хоста, проксирующего
запросы на другой контейнер.

Для этого необходимо разработать утилиту для управления внутренней кухней контейнера.
На первом приближении управление доменами через средства PowerDNS оставляем
пользователю, а создание и удаление виртуальных хостов и получение сертификатов берем на себя.

При построении контейнера необходимо скомпилировать систему инициализации Immortal,
которая написана на GO. Чтобы не нагружать построение контейнера дополнительными
зависимостями, средство для управления внутри контейнера можно написать на GO
и так же скомпилировать в процессе построения контейнера.

Проксировать запросы на контейнеры-приложения предлагается через
имя контейнера-приложения и порт, на котором поднято web-приложение.
Поэтому обязательным требованием является связь контейнера-приложения
с проксирующим контейнером через подсеть, созданную через docker.

Реализация
==========

Dns, Nginx, SSL
---------------

Для получения контейнера минимального размера будем использовать
базовый контейнер alpine:3.7.

В контейнере необходимо иметь:

    1. Легковесный текстовый редактор для редактирования доменной зоны
    2. PowerDNS
    3. Nginx
    4. Acme.sh
    5. Immortal
    6. Утилита для управления сервисами внутри контейнера

PowerDNS хранит всю информацию о зонах в базе данных.
В число доступных бекэндов входит SQLite3, MySQL, PosgreSQL и др.
Контейнер изначально не расчитывается на использование в качестве
высоконагруженного узла. Поэтому, чтобы образ и контейнер были
более легковесные используем бэкенд SQLite3.

Добавлять или удалять новые домены, записи и все остальное для
PowerDNS можно либо через прямое редактирование БД, либо через
утилиту ``pdnsutil``. Командой ``pdnsutil edit-zone $ZONE`` можно
отредактировать, добавить, удалить записи для зоны через текстовый
редактор.

В качестве текстового редактора используем Nano, поскольку он
не занимает большого объема внутри контейнера и является относительно
привычным для всех пользователей.

Установку Acme.sh производим при построении контейнера.
Для этого необходимо установить временную зависимость git.
Помимо прочего, необходимо иметь установленными openssl,
socat и curl.

Менеджер пакетов apk из Alpine дает возможность установить временные
пакеты как один виртуальный пакет с помощью флага ``--virtual``:

.. code-block:: bash

    apk add --no-cache --virtual .dependencies git linux-headers...

чтобы можно было удобно удалить эти пакеты, как они станут не нужны, с помощью:

.. code-block:: bash

    apk del .dependencies

При построении контейнера выполнять установку зависимостей их удаление
необходимо в пределах одного слоя. Иначе зависимости останутся на более
раннем слое и это приведет к увеличению размера всех слоев.

Для компиляции Immortal необходимо установить ряд временных зависимостей
и golang 1.9.1. И тут же можно будет скомпилировать код собственной утилиты
для управления сервисами контейнера.

Готовый Dockerfile можно посмотреть в `репозитории <https://suai-gogs.hlebushe.gq/src/master/>`_.

Manage.go
---------

Реализовывать основной функционал контейнера и интерфейс для доступа к нему
будем на языке GO с использованием пакета golang версии 1.9.1.
Для описания структуры CLI команд будем использовать пакет
``"github.com/jawher/mow.cli"``. Этот пакет (почти фреймворк)
позволяет достаточно гибко описывать иерархию команд и самостоятельно
умеет выводить красивые подсказочки для команд и флагов.

В первой итерации необходимо реализовать следующие команды:

    1. Добавление хоста + получение сертификата;
    2. Удаление хоста + отзыв сертификата;
    3. Перезапуск службы.

Касательно третьего пункта: если вдруг захочется сменить Immortal на что-то
другое, мы можем позволить себе это, критично не меняя ничего для
пользователя контейнера, поскольку он будет перезагружать службы через
эту утилиту.

Кроме того Acme.sh так же требует команду для перезагрузки веб-сервера.
Она актуальна для каждого сертификата в отдельности: после каждого
обновления сертификата acme.sh перезагружает веб-сервер, чтобы последний
подхватил новый сертификат. Если мы будем подсовывать acme.sh команду
рестарта Nginx через утилиту, то ничего не сломается, если, опять же,
мы поменяем Immortal на что-то другое.

Добавление хоста реализовано действиями, аналогичными тому, что
описано тут: :doc:`../other/bind-nginx-ssl-rtd.rst`.

Готовый код утилиты можно посмотреть в вышеупомянутом репозитории
в `директории /src
<https://suai-gogs.hlebushe.gq/MrP4p3r/dns-nginx-ssl/src/master/src>`_

Запуск контейнера
-----------------

Перед запуском контейнеров необходимо предотвратить проблему
с DNS серверами. Проблема заключается в том, что после
запуска локального DNS, другие контейнеры не получают ответы
от DNS. Проблема наверяка решается через некоторую опцию в PowerDNS,
но пока я ее найти не смог. Поэтому я сделал так:

.. code-block:: bash

    $ cat << EOF > /etc/docker/daemon.json
    {
      "dns": ["8.8.8.8", "8.8.4.4"]
    }
    EOF

Для упрощения запуска и обновления контейнера воспользуемся docker-compose.
Автор работы пользовался такой конфигурацией в "docker-compose.yml"::

    version: "3.5"

    services:
      dns-nginx-ssl:
        container_name: dns-nginx-ssl
        image: mrp4p3r/dns-nginx-ssl
        networks:
          - docker-subnet-0
        volumes:
          - pdns-db:/var/pdns
          - ssl-acme.sh:/root/.acme.sh
          - ssl-certs:/etc/sslcerts
          - nginx-vhosts:/etc/nginx/conf.d
        ports:
          - "53:53"
          - "53:53/udp"
          - "80:80"
          - "80:80/udp"
          - "443:443"
          - "443:443/udp"

    volumes:
      pdns-db:
      ssl-acme.sh:
      ssl-certs:
      nginx-vhosts:

    networks:
      docker-subnet-0
        external:
          name: docker-subnet-0

Для запуска контейнера выполняем::

    $ docker-compose pull
    $ docker-compose up -d

Запускаем ``sh`` внутри контейнера и выполняем несколько команд,
чтобы добавить наш собственный домен в PowerDNS и пару серверов
имен для зоны (freenom.com - где я арендовал домен - требует
наличия хотя бы двух серверов имен для зоны):

.. code-block:: bash

    $ docker exec -ti dns-nginx-ssl sh
    / # pdnsutil create-zone hlebushe.gq ns1.hlebushe.gq
    / # pdnsutil add-record hlebushe.gq ns2 NS ns2.hlebushe.gq
    / # pdnsutil add-record hlebushe.gq ns1 A 51.15.61.148
    / # pdnsutil add-record hlebushe.gq ns2 A 51.15.61.148

Той же командой ``pdnsutil add-record`` можно добавить несколько
записей для зоны:

.. code-block:: bash

    / # pdnsutil add-record hlebushe.gq . A 51.15.61.148
    / # pdnsutil add-record hlebushe.gq gnu-linux CNAME hlebushe.gq

Или же можно отредактировать записи зоны более привычным способом:

.. code-block:: bash

    / # pdnsutil edit-zone hlebushe.gq

Последнюю команду можно вызывать через ``docker exec``:

.. code-block:: bash

    # docker exec -ti dns-nginx-ssl \
          pdnsutil edit-zone hlebushe.gq

Добавляем оставшиеся поддомены для сервисов, которые мы хотим запустить.

    TODO: вставить скриншотик

Сохраняем, выходим из редактора и нажимаем "a" для применения изменений.
Теперь с помощью команды dig можно проверить, правильный ли адрес возвращает
нам DNS.

    TODO: вставить скриншотик

Теперь можно перейти к запуску приложений и предоставлению доступа к ним.

Запуск приложений
-----------------

Запустим три приложения:

    1. Небольшой трехстраничный сайт-песочницу
    2. Обратный прокси на документацию, размещенную на readthedocs.io
    3. Git-сервис Gogs
    4. Веб-интерфейс для Docker - Portainer

Каждое из приложений работает в контейнере. Каждый такой контейнер имеет порт,
который предоставляет доступ к приложению по протоколу HTTP.
Необходимо связать каждый контейнер с основным контейнером, запущенном на
предыущем шаге.

Контейнеры-приложения также запускаем через docker-compose. Для
первого приложения (трехстраничный сайт-песочница)::

    version: "3.5"

    services:
      hleb:
        container_name: hleb
        image: mrp4p3r/hlebushe.gq
        networks:
          - docker-subnet-0
        volumes:
          - ti2017-log:/var/log/ti2017

    volumes:
      ti2017-log:

    networks:
      docker-subnet-0:
        external:
          name: docker-subnet-0

Создание файла виртуального хоста, проксируюшего запросы на контейнер-приложение
и получение сертификата для используемого домена реализовано в утилите
для управления контейнером. Она доступна внутри контейнера по имени ``manage``.

Создадим привязку домена "hlebushe.gq" к контейнеру с именем "hleb"
с открытым портом 80 для HTTP запросов::

    $ docker exec -ti dns-nginx-ssl \
          manage host add \
              --domain hlebushe.gq
              --container hleb

// TODO: добавить скриншотик

Аналогично поднимаем остальные контейнеры: обратный прокси на readthedocs.io,
gogs/gogs, portainer/portainer.

Обратное проксирование на Read The Docs
---------------------------------------

Обратное проксирование реализовано как контейнер-приложение:
порт 80 доступен для HTTP запросов. Внутри контейнера
запросы проксируются через HTTPS на readthedocs.io.

Контейнер может использоваться для создания прокси на любую
документацию: при запуске контейнера необходимо указать
т. н. SLUG проекта и адрес документации на readthedocs.io.

Образ контейнера занимает 6 Мб. Внутри контейнера работает
Nginx с одним виртуальным хостом. В моем случае он использует
порядка 30 Мб оперативной памяти ради проксирования на одну
документацию. Это, вроде, не особо хорошо.

В любом случае, это скорее временное решение. Создание прокси
на документацию в обозримом будущем можно реализовать отдельной
командой в контейнере "dns-nginx-ssl", в котором происходит
и получение сертификата на собственные доменные имена.

Посмотреть Dockerfile и скрипт инициализации контейнера
для проксирования на документацию можно посмотреть
`тут <https://github.com/MrP4p3r/rtd-reverse-proxy>`_.

Итоги
=====

В процессе выполнения работы был разработан легковесный контейнер,
выполняющий роль DNS и проксирующего веб-сервера, позволяющий
за пару команд предоставлять доступ к контейнеризированному приложению
по протоколу HTTPS с автоматизацией получения сертификата letsencrypt.org
через утилиту acme.sh.

Дополнительно
=============

Материалы:

    1. Справка по PowerDNS
    2. Справка (репозиторий) по acme.sh

Ссылки на репозитории:

    1. Разработанный контейнер dns-nginx-ssl
    2. Контейнер обратный прокси на документацию

